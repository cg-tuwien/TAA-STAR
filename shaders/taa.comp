#version 460
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : enable

#include "shader_cpu_common.h"

// ###### SRC/DST IMAGES #################################
layout(set = 0, binding = 0) uniform sampler uSampler;
layout(set = 0, binding = 1) uniform texture2D uCurrentFrame;
layout(set = 0, binding = 2) uniform texture2D uCurrentDepth;
layout(set = 0, binding = 3) uniform texture2D uHistoryFrame;
layout(set = 0, binding = 4) uniform texture2D uHistoryDepth;
layout(set = 0, binding = 5, TAA_SHADER_OUTPUT_FORMAT) writeonly uniform restrict image2D uResult;
layout(set = 0, binding = 6, rgba16f) writeonly uniform restrict image2D uDebug;
// -------------------------------------------------------

// ###### PUSH CONSTANTS AND UBOs ########################
layout(push_constant) uniform PushConstants {
	vec4 mJitterAndAlpha;
	int  mColorClampingOrClipping;
	bool mDepthCulling;
	bool mTextureLookupUnjitter;
	bool mBypassHistoryUpdate;
	bool mUseYCoCg;
	bool mVarianceClipping;
	float mVarClipGamma;
	float mRejectionAlpha;
	int  mDebugMode;
	float mDebugScale;
} pushConstants;

layout(set = 1, binding = 0) uniform Matrices {
	mat4 mHistoryViewProjMatrix;
	mat4 mInverseViewProjMatrix;
} uboMat;
// -------------------------------------------------------

// Just for debugging:
vec4 gDebugValue = vec4(0);

// ###### HELPER FUNCTIONS ###############################

// convert from RGB to YCoCg-R ; see https://en.wikipedia.org/wiki/YCoCg
vec3 rgb_to_ycocg(vec3 c) {
	float co  = c.r - c.b;
	float tmp = c.b + co * .5;
	float cg  = c.g - tmp;
	float y   = tmp + cg * .5;
	return vec3(y,co,cg);
}

// convert from YCoCg-R to RGB
vec3 ycocg_to_rgb(vec3 c) {
	float tmp = c.x - c.z * .5;
	float g   = c.z + tmp;
	float b   = tmp - c.y * .5;
	float r   = b + c.y;
	return vec3(r,g,b);
}

vec3 maybe_rgb_to_ycocg(vec3 c) { return pushConstants.mUseYCoCg ? rgb_to_ycocg(c) : c; }
vec3 maybe_ycocg_to_rgb(vec3 c) { return pushConstants.mUseYCoCg ? ycocg_to_rgb(c) : c; }

void getNeighbourhood(in ivec2 iuv, out vec3 cC, out vec3 c1, out vec3 c2, out vec3 c3, out vec3 c4, out vec3 c5, out vec3 c6, out vec3 c7, out vec3 c8) {
	vec2 offset = vec2(0.0, 0.0);
	if (pushConstants.mTextureLookupUnjitter) {
		offset = pushConstants.mJitterAndAlpha.xy;
	}
	vec2 invsize = vec2(1) / textureSize(uCurrentFrame, 0);

	cC = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv                 + 0.5) * invsize).rgb);
	c1 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1, -1) + 0.5) * invsize).rgb);
	c2 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0, -1) + 0.5) * invsize).rgb);
	c3 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1, -1) + 0.5) * invsize).rgb);
	c4 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  0) + 0.5) * invsize).rgb);
	c5 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  0) + 0.5) * invsize).rgb);
	c6 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  1) + 0.5) * invsize).rgb);
	c7 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0,  1) + 0.5) * invsize).rgb);
	c8 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  1) + 0.5) * invsize).rgb);
}

void getColorAndAabb(in ivec2 iuv, out vec3 centerCol, out vec3 minCol, out vec3 maxCol, out vec3 cliptowardsCol)
{
	const float N = 9.0; // number of samples
	vec3 c1,c2,c3,c4,c5,c6,c7,c8;
	getNeighbourhood(iuv, centerCol,c1,c2,c3,c4,c5,c6,c7,c8);

	// variance clipping?
	if (pushConstants.mVarianceClipping) {
		vec3 m1 = centerCol + c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8;
		vec3 m2 = centerCol*centerCol + c1*c1 + c2*c2 + c3*c3 + c4*c4 + c5*c5 + c6*c6 + c7*c7 + c8*c8;
		vec3 mean = m1 / N;
		vec3 sigma = sqrt(max(vec3(0), m2 / N - mean * mean));	// !! Here be dragons! (due to precision? - without the max(), some sigma components can get NaN!)
		minCol = mean - pushConstants.mVarClipGamma * sigma;
		maxCol = mean + pushConstants.mVarClipGamma * sigma;

		// NOTE: it is NOT guaranteed that centerCol is inside the AABB !
		// so clip towards the mean
		cliptowardsCol = mean;

		// TODO: we can even clip the other AABB against this one
	} else {
		minCol = min(min(min(min(min(min(min(min(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
		maxCol = max(max(max(max(max(max(max(max(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
		cliptowardsCol = centerCol; // here centerCol is always inside the AABB; note: playdead still clip towards average color 
	}

	// TODO: optionally unjitter differently: neighbourhood samples, current color -> need to make sure cliptowardsCol stays inside AABB

	//if (any(lessThan(centerCol, minCol)) || any(greaterThan(centerCol, maxCol))) gDebugValue = vec4(1,0,0,0);
}

// Code from Temporal Reprojection Anti-Aliasing in INSIDE: https://youtu.be/2XXS5UyNjjU?t=939
// note: clips towards aabb center + p.w
vec4 clipAabb(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'		// only p.w is used (and typically is 1)
	vec4 q)       // c_hist
{
	const float eps = 1e-7;

	vec3 pClip = 0.5 * (aabbMax + aabbMin);
	vec3 eClip = 0.5 * (aabbMax - aabbMin) + eps; // ac: added epsilon

	vec4 vClip = q - vec4(pClip, p.w);
	vec3 vUnit = vClip.xyz / eClip;
	vec3 aUnit = abs(vUnit);
	float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));

	if (maUnit > 1.0) {
		return vec4(pClip, p.w) + vClip / maUnit;
	}
	else {
		return q; // point inside aabb
	}
}

// slow clipping, but not only towards centre; code from playdead -- DOES NOT WORK PROPERLY!
vec4 clipAabbSlow(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'
	vec4 q)       // c_hist
{
		vec4 r = q - p;
		vec3 rmax = aabbMax - p.xyz;
		vec3 rmin = aabbMin - p.xyz;

		const float eps = 1e-7;

		// !! BEWARE !! divs by zero happen here !!
		if (r.x > rmax.x + eps) r *= (rmax.x / r.x);
		if (r.y > rmax.y + eps) r *= (rmax.y / r.y);
		if (r.z > rmax.z + eps) r *= (rmax.z / r.z);
		if (r.x < rmin.x - eps) r *= (rmin.x / r.x);
		if (r.y < rmin.y - eps) r *= (rmin.y / r.y);
		if (r.z < rmin.z - eps) r *= (rmin.z / r.z);

		return p + r;
}

#if TAA_OUTPUT_IS_SRGB
float srgbGammaCorr(float color)
{
	if (color <= 0.0031308)
		return 12.92 * color;

	float a = 0.055;
	return (1 + a) * pow(color, 1 / 2.4) - a;
}

vec3 rgb2srgb(vec3 rgb)
{
	vec3 srgb;
	srgb.r = srgbGammaCorr(rgb.r);
	srgb.g = srgbGammaCorr(rgb.g);
	srgb.b = srgbGammaCorr(rgb.b);
	return srgb;
}

#define TO_OUTPUT_FORMAT(x) rgb2srgb((x))
#else
#define TO_OUTPUT_FORMAT(x) (x)
#endif

// -------------------------------------------------------

// ################## COMPUTE SHADER MAIN ###################
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
	ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(iuv) + 0.5) / textureSize(uCurrentFrame, 0);

	if (pushConstants.mBypassHistoryUpdate) {
		imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(texelFetch(uHistoryFrame, iuv, 0).rgb), 1));
		imageStore(uDebug,  iuv, vec4(0));
		return;
	}

	bool rejected  = false;
	bool rectified = false;
	vec3 rectified_diff;
	
	vec3 currentColor;
	vec3 colMin;
	vec3 colMax;
	vec3 colClipTowards;
	getColorAndAabb(iuv, currentColor, colMin, colMax, colClipTowards);		// colors are in YCoGg (if enabled)
	float depth = texelFetch(uCurrentDepth, iuv, 0).r;
	
	vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1);
	vec4 worldSpace = uboMat.mInverseViewProjMatrix * clipSpace;
	vec4 historyClipSpace = uboMat.mHistoryViewProjMatrix * worldSpace;
	vec2 historyUv = (historyClipSpace.xy / historyClipSpace.w) * 0.5 + 0.5;
	ivec2 iHistoryUv = ivec2(historyUv * textureSize(uCurrentDepth, 0));
	float expectedHistoryDepth = historyClipSpace.z / historyClipSpace.w;
	
	vec3 historyColor = maybe_rgb_to_ycocg(texture(sampler2D(uHistoryFrame, uSampler), historyUv).rgb);

	vec2 jitter = pushConstants.mJitterAndAlpha.xy;
	float alpha = pushConstants.mJitterAndAlpha.a;

	// ---- history rejection ----
	// cull by depth
	if (pushConstants.mDepthCulling) {
		float historyDepth = texelFetch(uHistoryDepth, iHistoryUv, 0).r;
		float depthEpsilon = 0.1 * (1.0 - historyDepth);
		if (abs(historyDepth - expectedHistoryDepth) > depthEpsilon) {
			alpha = pushConstants.mRejectionAlpha;
			rejected = true;
		}
	}

	// ---- history rectification ----
	vec3 origHistorColor = historyColor;

	// clip/clamp color
	switch (pushConstants.mColorClampingOrClipping) {
		case 1:
			historyColor = clamp(historyColor, colMin, colMax);
			break;
		case 2:
			//historyColor = clipAabb(colMin, colMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;
			// TODO: Implemented ^ this in a hurry => not properly tested and verified yet.
			historyColor = clipAabb(colMin, colMax, vec4(0,0,0,1), vec4(historyColor, 1.0)).rgb;
			break;
		case 3:
			//historyColor = clipAabbSlow(colMin, colMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;	// this one has "fireflies" or "blackout"-problems with var clipping (even after fixing sigma-NaNs)
			//historyColor = clipAabbSlow(colMin, colMax, vec4(colAvg, 1.0), vec4(historyColor, 1.0)).rgb;			// not this... WHY NOT?	===> see getNeighbourhood, currentColor may NOT be inside AABB!
			historyColor = clipAabbSlow(colMin, colMax, vec4(colClipTowards, 1.0), vec4(historyColor, 1.0)).rgb;
			break;

	}

	rectified_diff = historyColor - origHistorColor;
	rectified = any(greaterThan(abs(rectified_diff), vec3(0.001)));


	// ---- blending ----
	vec3 antiAliased = maybe_ycocg_to_rgb(currentColor) * alpha + maybe_ycocg_to_rgb(historyColor) * (1.0 - alpha);

	// if TAA_OUTPUT_IS_SRGB:
	// write rgb into uResult
	// - imageStore() cannot handle sRGB images
	// - we write sRGB values into an RGB image and copy the image into an sRGB image later as a workaround
	// => we have to manually convert linear RGB to sRGB

	imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(antiAliased), 1.0));

	// --- debug ---

	if (pushConstants.mDebugMode == 0) {
		// colour bounding box, individual
		vec3 tmp = colMax - colMin;
		imageStore(uDebug,  iuv, vec4(tmp, 0));
	} else if (pushConstants.mDebugMode == 1) {
		// colour bounding box, size
		vec3 tmp = colMax - colMin;
		imageStore(uDebug,  iuv, vec4(vec3(tmp.x * tmp.y * tmp.z) * pushConstants.mDebugScale, 0));
	} else if (pushConstants.mDebugMode == 2) {
		//imageStore(uDebug,  iuv, vec4(rejected ? 1 : 0, rectified ? 1 : 0, 0, 0));
		imageStore(uDebug,  iuv, vec4(rejected ? 1 : 0, length(rectified_diff) * pushConstants.mDebugScale, 0, 0));
	} else {
		imageStore(uDebug,  iuv, gDebugValue);
	}

}
// -------------------------------------------------------

