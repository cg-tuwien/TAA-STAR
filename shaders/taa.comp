#version 460
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : enable

// ###### SRC/DST IMAGES #################################
layout(set = 0, binding = 0) uniform sampler uSampler;
layout(set = 0, binding = 1) uniform texture2D uCurrentFrame;
layout(set = 0, binding = 2) uniform texture2D uCurrentDepth;
layout(set = 0, binding = 3) uniform texture2D uHistoryFrame;
layout(set = 0, binding = 4) uniform texture2D uHistoryDepth;
layout(set = 0, binding = 5, r16f) writeonly uniform restrict image2D uResult;
// -------------------------------------------------------

// ###### PUSH CONSTANTS AND UBOs ########################
layout(push_constant) uniform PushConstants {
	vec4 mJitterAndAlpha;
	int mColorClampingOrClipping;
	bool mDepthCulling;
	bool mTextureLookupUnjitter;
	bool mBypassHistoryUpdate;
} pushConstants;

layout(set = 1, binding = 0) uniform Matrices {
	mat4 mHistoryViewProjMatrix;
	mat4 mInverseViewProjMatrix;
} uboMat;
// -------------------------------------------------------

// ###### HELPER FUNCTIONS ###############################

void getColorAndRgbAabb(in ivec2 iuv, out vec3 centerRgb, out vec3 minRgb, out vec3 maxRgb)
{
	vec2 offset = vec2(0.0, 0.0);
	if (pushConstants.mTextureLookupUnjitter) {
		offset = pushConstants.mJitterAndAlpha.xy;
	}

	vec2 size = textureSize(uCurrentFrame, 0);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1, -1) + 0.5) / size).rgb; minRgb =             centerRgb ; maxRgb =             centerRgb ;
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0, -1) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1, -1) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  0) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  0) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  1) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0,  1) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  1) + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
	centerRgb = texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv                 + 0.5) / size).rgb; minRgb = min(minRgb, centerRgb); maxRgb = max(maxRgb, centerRgb);
}

// Code from Temporal Reprojection Anti-Aliasing in INSIDE: https://youtu.be/2XXS5UyNjjU?t=939
// note: clips towards aabb center + p.w
vec4 clipAabb(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'
	vec4 q)       // c_hist
{
	vec3 pClip = 0.5 * (aabbMax + aabbMin);
	vec3 eClip = 0.5 * (aabbMax - aabbMin);

	vec4 vClip = q - vec4(pClip, p.w);
	vec3 vUnit = vClip.xyz / eClip;
	vec3 aUnit = abs(vUnit);
	float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));

	if (maUnit > 1.0) {
		return vec4(pClip, p.w) + vClip / maUnit;
	}
	else {
		return q; // point inside aabb
	}
}

float srgbGammaCorr(float color)
{
	if (color <= 0.0031308)
		return 12.92 * color;

	float a = 0.055;
	return (1 + a) * pow(color, 1 / 2.4) - a;
}

vec3 rgb2srgb(vec3 rgb)
{
	vec3 srgb;
	srgb.r = srgbGammaCorr(rgb.r);
	srgb.g = srgbGammaCorr(rgb.g);
	srgb.b = srgbGammaCorr(rgb.b);
	return srgb;
}
// -------------------------------------------------------

// ################## COMPUTE SHADER MAIN ###################
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
	ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(iuv) + 0.5) / textureSize(uCurrentFrame, 0);

	if (pushConstants.mBypassHistoryUpdate) {
		imageStore(uResult, iuv, vec4(rgb2srgb(texelFetch(uHistoryFrame, iuv, 0).rgb), 1));
		return;
	}
	
	vec3 currentColor;
	vec3 rgbMin;
	vec3 rgbMax;
	getColorAndRgbAabb(iuv, currentColor, rgbMin, rgbMax);
	float depth = texelFetch(uCurrentDepth, iuv, 0).r;
	
	vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1);
	vec4 worldSpace = uboMat.mInverseViewProjMatrix * clipSpace;
	vec4 historyClipSpace = uboMat.mHistoryViewProjMatrix * worldSpace;
	vec2 historyUv = (historyClipSpace.xy / historyClipSpace.w) * 0.5 + 0.5;
	ivec2 iHistoryUv = ivec2(historyUv * textureSize(uCurrentDepth, 0));
	float expectedHistoryDepth = historyClipSpace.z / historyClipSpace.w;
	
	vec3 historyColor = texture(sampler2D(uHistoryFrame, uSampler), historyUv).rgb;

	vec2 jitter = pushConstants.mJitterAndAlpha.xy;
	float alpha = pushConstants.mJitterAndAlpha.a;

	// cull by depth
	if (pushConstants.mDepthCulling) {
		float historyDepth = texelFetch(uHistoryDepth, iHistoryUv, 0).r;
		float depthEpsilon = 0.1 * (1.0 - historyDepth);
		if (abs(historyDepth - expectedHistoryDepth) > depthEpsilon) {
			alpha = 1;
		}
	}

	// clip color
	switch (pushConstants.mColorClampingOrClipping) {
		case 1:
			historyColor = clamp(historyColor, rgbMin, rgbMax);
			break;
		case 2:
			historyColor = clipAabb(rgbMin, rgbMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;
			// TODO: Implemented ^ this in a hurry => not properly tested and verified yet.
			break;
	}

	vec3 antiAliased = currentColor * alpha + historyColor * (1 - alpha);

	#if 0
	// show size of colour bounding box
	vec3 tmp = rgbMax - rgbMin;
	//antiAliased = tmp;
	antiAliased = vec3(tmp.x * tmp.y * tmp.z);
	#endif

	// write rgb into uResult
	// - imageStore() cannot handle sRGB images
	// - we write sRGB values into an RGB image and copy the image into an sRGB image later as a workaround
	// => we have to manually convert linear RGB to sRGB
	vec3 srgb = rgb2srgb(antiAliased);

	imageStore(uResult, iuv, vec4(srgb, 1.0));
}
// -------------------------------------------------------

