#version 460
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : enable

#include "shader_cpu_common.h"

// ###### SRC/DST IMAGES #################################
layout(set = 0, binding = 0) uniform sampler uSampler;
layout(set = 0, binding = 1) uniform texture2D uCurrentFrame;
layout(set = 0, binding = 2) uniform texture2D uCurrentDepth;
layout(set = 0, binding = 7) uniform texture2D uCurrentVelocity;
layout(set = 0, binding = 3) uniform texture2D uHistoryFrame;
layout(set = 0, binding = 4) uniform texture2D uHistoryDepth;
layout(set = 0, binding = 5, TAA_SHADER_OUTPUT_FORMAT) writeonly uniform restrict image2D uResult;
layout(set = 0, binding = 6, rgba16f) writeonly uniform restrict image2D uDebug;
// -------------------------------------------------------

// ###### PUSH CONSTANTS AND UBOs ########################
layout(push_constant) uniform PushConstants {
	vec4 mJitterAndAlpha;
	int  mColorClampingOrClipping;
	bool mDepthCulling;
	//bool mTextureLookupUnjitter;
	bool mUnjitterNeighbourhood;
	bool mUnjitterCurrentSample;		// TODO: anything for depth/history depth??
	float mUnjitterFactor;				// -1 or +1

	bool mBypassHistoryUpdate;
	bool mUseYCoCg;
	bool mVarianceClipping;
	bool mLumaWeighting;
	float mVarClipGamma;
	float mMinAlpha;			// used for luminance-based weighting
	float mMaxAlpha;			// used for luminance-based weighting
	float mRejectionAlpha;
	bool mRejectOutside;
	int mUseVelocityVectors;		// 0=off 1=for movers only 2=for everything

	int  mDebugMode;
	float mDebugScale;
	bool mDebugCenter;
} pushConstants;

layout(set = 1, binding = 0) uniform Matrices {
	mat4 mHistoryViewProjMatrix;
	mat4 mInverseViewProjMatrix;
} uboMat;
// -------------------------------------------------------

// Just for debugging:
vec4 gDebugValue = vec4(0);

// ###### HELPER FUNCTIONS ###############################

//// convert from RGB to YCoCg-R ; see https://en.wikipedia.org/wiki/YCoCg
//vec3 rgb_to_ycocg(vec3 c) {
//	float co  = c.r - c.b;
//	float tmp = c.b + co * .5;
//	float cg  = c.g - tmp;
//	float y   = tmp + cg * .5;
//	return vec3(y,co,cg);
//}
//
//// convert from YCoCg-R to RGB
//vec3 ycocg_to_rgb(vec3 c) {
//	float tmp = c.x - c.z * .5;
//	float g   = c.z + tmp;
//	float b   = tmp - c.y * .5;
//	float r   = b + c.y;
//	return vec3(r,g,b);
//}

// convert from RGB to YCoCg ; see https://en.wikipedia.org/wiki/YCoCg
vec3 rgb_to_ycocg(vec3 c) {
	return vec3(
		 .25 * c.r + .5 * c.g + .25 * c.b,
		 .5  * c.r            - .5  * c.b,
		-.25 * c.r + .5 * c.g - .25 * c.b
	);
}

// convert from YCoCg to RGB
vec3 ycocg_to_rgb(vec3 c) {
	float tmp = c.x - c.z;	// tmp = Y   - Cg;
	return vec3(
		tmp + c.y,	// R   = tmp + Co;
		c.x + c.z,	// G   = Y   + Cg;
		tmp - c.y	// B   = tmp - Co;
	);
}


vec3 maybe_rgb_to_ycocg(vec3 c) { return pushConstants.mUseYCoCg ? rgb_to_ycocg(c) : c; }
vec3 maybe_ycocg_to_rgb(vec3 c) { return pushConstants.mUseYCoCg ? ycocg_to_rgb(c) : c; }
float luminance(vec3 c) { return pushConstants.mUseYCoCg ? c.x : rgb_to_ycocg(c).x; }

void getNeighbourhood(in ivec2 iuv, out vec3 cC, out vec3 c1, out vec3 c2, out vec3 c3, out vec3 c4, out vec3 c5, out vec3 c6, out vec3 c7, out vec3 c8) {
//	vec2 offset = vec2(0.0, 0.0);
//	if (pushConstants.mTextureLookupUnjitter) {
//		offset = pushConstants.mJitterAndAlpha.xy;
//	}
	
	vec2 offset = pushConstants.mUnjitterNeighbourhood ? pushConstants.mJitterAndAlpha.xy * pushConstants.mUnjitterFactor : vec2(0);

	vec2 invsize = vec2(1) / textureSize(uCurrentFrame, 0);

	cC = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv                 + 0.5) * invsize).rgb);
	c1 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1, -1) + 0.5) * invsize).rgb);
	c2 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0, -1) + 0.5) * invsize).rgb);
	c3 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1, -1) + 0.5) * invsize).rgb);
	c4 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  0) + 0.5) * invsize).rgb);
	c5 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  0) + 0.5) * invsize).rgb);
	c6 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  1) + 0.5) * invsize).rgb);
	c7 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0,  1) + 0.5) * invsize).rgb);
	c8 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  1) + 0.5) * invsize).rgb);
}

// may have different unjitter settings than getNeighbourhood
vec3 getCurrentColor(in ivec2 iuv) {
	vec2 offset = pushConstants.mUnjitterCurrentSample ? pushConstants.mJitterAndAlpha.xy * pushConstants.mUnjitterFactor : vec2(0);
	vec2 invsize = vec2(1) / textureSize(uCurrentFrame, 0);
	return maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + 0.5) * invsize).rgb);
}

void getColorAndAabb(in ivec2 iuv, out vec3 centerCol, out vec3 minCol, out vec3 maxCol, out vec3 cliptowardsCol)
{
	const float N = 9.0; // number of samples
	vec3 c1,c2,c3,c4,c5,c6,c7,c8;
	getNeighbourhood(iuv, centerCol,c1,c2,c3,c4,c5,c6,c7,c8);

	// variance clipping?
	if (pushConstants.mVarianceClipping) {
		vec3 m1 = centerCol + c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8;
		vec3 m2 = centerCol*centerCol + c1*c1 + c2*c2 + c3*c3 + c4*c4 + c5*c5 + c6*c6 + c7*c7 + c8*c8;
		vec3 mean = m1 / N;
		vec3 sigma = sqrt(max(vec3(0), m2 / N - mean * mean));	// !! Here be dragons! (due to precision? - without the max(), some sigma components can get NaN!)
		minCol = mean - pushConstants.mVarClipGamma * sigma;
		maxCol = mean + pushConstants.mVarClipGamma * sigma;

		// NOTE: it is NOT guaranteed that centerCol is inside the AABB !
		// so clip towards the mean
		cliptowardsCol = mean;

		// TODO: we can even clip the other AABB against this one
	} else {
		minCol = min(min(min(min(min(min(min(min(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
		maxCol = max(max(max(max(max(max(max(max(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
		cliptowardsCol = centerCol; // here centerCol is always inside the AABB; note: playdead still clip towards average color 
	}

	// TODO: optionally unjitter differently: neighbourhood samples, current color -> need to make sure cliptowardsCol stays inside AABB

	//if (any(lessThan(centerCol, minCol)) || any(greaterThan(centerCol, maxCol))) gDebugValue = vec4(1,0,0,0);
}

// Code from Temporal Reprojection Anti-Aliasing in INSIDE: https://youtu.be/2XXS5UyNjjU?t=939
// note: clips towards aabb center + p.w
vec4 clipAabb(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'		// only p.w is used (and typically is 1)
	vec4 q)       // c_hist
{
	const float eps = 1e-7;

	vec3 pClip = 0.5 * (aabbMax + aabbMin);
	vec3 eClip = 0.5 * (aabbMax - aabbMin) + eps; // ac: added epsilon

	vec4 vClip = q - vec4(pClip, p.w);
	vec3 vUnit = vClip.xyz / eClip;
	vec3 aUnit = abs(vUnit);
	float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));

	if (maUnit > 1.0) {
		return vec4(pClip, p.w) + vClip / maUnit;
	}
	else {
		return q; // point inside aabb
	}
}

// slow clipping, but not only towards centre; code from playdead -- DOES NOT WORK PROPERLY!
vec4 clipAabbSlow(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'
	vec4 q)       // c_hist
{
		vec4 r = q - p;
		vec3 rmax = aabbMax - p.xyz;
		vec3 rmin = aabbMin - p.xyz;

		const float eps = 1e-7;

		// !! BEWARE !! divs by zero happen here !!
		if (r.x > rmax.x + eps) r *= (rmax.x / r.x);
		if (r.y > rmax.y + eps) r *= (rmax.y / r.y);
		if (r.z > rmax.z + eps) r *= (rmax.z / r.z);
		if (r.x < rmin.x - eps) r *= (rmin.x / r.x);
		if (r.y < rmin.y - eps) r *= (rmin.y / r.y);
		if (r.z < rmin.z - eps) r *= (rmin.z / r.z);

		return p + r;
}

#if TAA_OUTPUT_IS_SRGB
float srgbGammaCorr(float color)
{
	if (color <= 0.0031308)
		return 12.92 * color;

	float a = 0.055;
	return (1 + a) * pow(color, 1 / 2.4) - a;
}

vec3 rgb2srgb(vec3 rgb)
{
	vec3 srgb;
	srgb.r = srgbGammaCorr(rgb.r);
	srgb.g = srgbGammaCorr(rgb.g);
	srgb.b = srgbGammaCorr(rgb.b);
	return srgb;
}

#define TO_OUTPUT_FORMAT(x) rgb2srgb((x))
#else
#define TO_OUTPUT_FORMAT(x) (x)
#endif

void getHistoryPosition(in vec2 currentUv, in float currentDepth, out vec2 historyUv, out float historyDepth) {
	vec4 velocitySample = texture(sampler2D(uCurrentVelocity, uSampler), currentUv);

	bool canUseVelocity = true;
	if (pushConstants.mUseVelocityVectors == 0 || (pushConstants.mUseVelocityVectors == 1 && velocitySample.w < 0.5)) canUseVelocity = false;

	if (canUseVelocity) {
		// velocity sample is already scaled from ndc to uv in .xy, .z holds the raw (ndc) depth difference
		historyUv    = currentUv    - velocitySample.xy;
		historyDepth = currentDepth - velocitySample.z;
		// TODO: check if material history is same object and set canUseVelocity = false otherwise
	}

	if (!canUseVelocity) {
		vec4 clipSpace = vec4(currentUv * 2.0 - 1.0, currentDepth, 1);
		vec4 worldSpace = uboMat.mInverseViewProjMatrix * clipSpace;
		vec4 historyClipSpace = uboMat.mHistoryViewProjMatrix * worldSpace;
		historyUv = (historyClipSpace.xy / historyClipSpace.w) * 0.5 + 0.5;
		historyDepth = historyClipSpace.z / historyClipSpace.w;
	}

	// TODO: need to adjust for current jitter if history buf is considered unjittered?
}

// -------------------------------------------------------

// ################## COMPUTE SHADER MAIN ###################
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
	ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);
	if (any(greaterThanEqual(iuv, textureSize(uCurrentFrame, 0)))) return;

	vec2 uv = (vec2(iuv) + 0.5) / textureSize(uCurrentFrame, 0);

	if (pushConstants.mBypassHistoryUpdate) {
		imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(texelFetch(uHistoryFrame, iuv, 0).rgb), 1));
		imageStore(uDebug,  iuv, vec4(0));
		return;
	}

	bool rejected  = false;
	bool rectified = false;
	vec3 rectified_diff;
	
	vec3 currentColor;
	vec3 colMin;
	vec3 colMax;
	vec3 colClipTowards;
	getColorAndAabb(iuv, currentColor, colMin, colMax, colClipTowards);		// colors are in YCoGg (if enabled)
	currentColor = getCurrentColor(iuv); // may have different unjitter settings than neighbourhood
	float depth = texelFetch(uCurrentDepth, iuv, 0).r;
	
//	vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1);
//	vec4 worldSpace = uboMat.mInverseViewProjMatrix * clipSpace;
//	vec4 historyClipSpace = uboMat.mHistoryViewProjMatrix * worldSpace;
//	vec2 historyUv = (historyClipSpace.xy / historyClipSpace.w) * 0.5 + 0.5;
//	float expectedHistoryDepth = historyClipSpace.z / historyClipSpace.w;
	vec2 historyUv;
	float expectedHistoryDepth;
	getHistoryPosition(uv, depth, historyUv, expectedHistoryDepth);
	ivec2 iHistoryUv = ivec2(historyUv * textureSize(uCurrentFrame, 0));
	
	vec3 historyColor = maybe_rgb_to_ycocg(texture(sampler2D(uHistoryFrame, uSampler), historyUv).rgb);

	vec2 jitter = pushConstants.mJitterAndAlpha.xy;
	float alpha = pushConstants.mJitterAndAlpha.a;

	// ---- history rejection ----
	// reject out-of-texture history samples
	if (pushConstants.mRejectOutside) {
		if (any(lessThan(historyUv, vec2(0))) || any(greaterThanEqual(historyUv, vec2(1)))) {
			alpha = pushConstants.mRejectionAlpha;
			rejected = true;
		}
	}

	// cull by depth
	if (pushConstants.mDepthCulling) {
		// FIXME - shouldn't we better compare LINEAR depth?

		float historyDepth = texelFetch(uHistoryDepth, iHistoryUv, 0).r;
		float depthEpsilon = 0.1 * (1.0 - historyDepth);
		if (abs(historyDepth - expectedHistoryDepth) > depthEpsilon) {
			alpha = pushConstants.mRejectionAlpha;
			rejected = true;
		}
	}

	// ---- history rectification ----
	vec3 origHistorColor = historyColor;

	// clip/clamp color
	switch (pushConstants.mColorClampingOrClipping) {
		case 1:
			historyColor = clamp(historyColor, colMin, colMax);
			break;
		case 2:
			//historyColor = clipAabb(colMin, colMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;
			// TODO: Implemented ^ this in a hurry => not properly tested and verified yet.
			historyColor = clipAabb(colMin, colMax, vec4(0,0,0,1), vec4(historyColor, 1.0)).rgb;
			break;
		case 3:
			//historyColor = clipAabbSlow(colMin, colMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;	// this one has "fireflies" or "blackout"-problems with var clipping (even after fixing sigma-NaNs)
			//historyColor = clipAabbSlow(colMin, colMax, vec4(colAvg, 1.0), vec4(historyColor, 1.0)).rgb;			// not this... WHY NOT?	===> see getNeighbourhood, currentColor may NOT be inside AABB!
			historyColor = clipAabbSlow(colMin, colMax, vec4(colClipTowards, 1.0), vec4(historyColor, 1.0)).rgb;
			break;

	}

	rectified_diff = historyColor - origHistorColor;
	rectified = any(greaterThan(abs(rectified_diff), vec3(0.001)));


	// ---- blending ----

	if (!rejected) {
		// dynamic luma weighting - see Timothy Lottes https://www.youtube.com/watch?v=WzpLWzGvFK4&t=18m
		if (pushConstants.mLumaWeighting) {
			float lumaCurrent = luminance(currentColor);
			float lumaHistory = luminance(historyColor);
			float diff = abs(lumaCurrent - lumaHistory) / max(max(lumaCurrent, lumaHistory), 0.2);
			float w = 1.0 - diff;
			float ww = w * w;
			// ww=0: bad history, use max alpha ; ww=1: good history, use min alpha
			alpha = mix(pushConstants.mMaxAlpha, pushConstants.mMinAlpha, ww);
		}
	}

	vec3 antiAliased = mix(maybe_ycocg_to_rgb(historyColor), maybe_ycocg_to_rgb(currentColor), alpha);	// current * a + history * (1-a)

	// if TAA_OUTPUT_IS_SRGB:
	// write rgb into uResult
	// - imageStore() cannot handle sRGB images
	// - we write sRGB values into an RGB image and copy the image into an sRGB image later as a workaround
	// => we have to manually convert linear RGB to sRGB

	imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(antiAliased), 1.0));

	// --- debug ---

	if (pushConstants.mDebugMode == 0) {
		// colour bounding box, individual
		vec3 tmp = colMax - colMin;
		gDebugValue = vec4(tmp, 0);
	} else if (pushConstants.mDebugMode == 1) {
		// colour bounding box, size
		vec3 tmp = colMax - colMin;
		gDebugValue = vec4(vec3(tmp.x * tmp.y * tmp.z), 0);
	} else if (pushConstants.mDebugMode == 2) {
		//imageStore(uDebug,  iuv, vec4(rejected ? 1 : 0, rectified ? 1 : 0, 0, 0));
		gDebugValue = vec4(rejected ? 1 : 0, length(rectified_diff), 0, 0);
	} else if (pushConstants.mDebugMode == 3) {
		gDebugValue = vec4(vec3(alpha), 0);
	} else if (pushConstants.mDebugMode == 4) {
		gDebugValue = texelFetch(uCurrentVelocity, iuv, 0);
	}
	// else keep current gDebugValue

	gDebugValue *= pushConstants.mDebugScale;
	if (pushConstants.mDebugCenter) gDebugValue = gDebugValue * 0.5 + 0.5;
	imageStore(uDebug,  iuv, gDebugValue);

}
// -------------------------------------------------------

