#version 460
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : enable

#include "shader_cpu_common.h"

// ###### SRC/DST IMAGES #################################
layout(set = 0, binding = 0) uniform sampler uSampler;
layout(set = 0, binding = 1) uniform texture2D uCurrentFrame;
layout(set = 0, binding = 2) uniform texture2D uCurrentDepth;
layout(set = 0, binding = 3) uniform texture2D uHistoryFrame;
layout(set = 0, binding = 4) uniform texture2D uHistoryDepth;
layout(set = 0, binding = 5, TAA_SHADER_OUTPUT_FORMAT) writeonly uniform restrict image2D uResult;
layout(set = 0, binding = 6, r16f) writeonly uniform restrict image2D uDebug;
// -------------------------------------------------------

// ###### PUSH CONSTANTS AND UBOs ########################
layout(push_constant) uniform PushConstants {
	vec4 mJitterAndAlpha;
	int  mColorClampingOrClipping;
	bool mDepthCulling;
	bool mTextureLookupUnjitter;
	bool mBypassHistoryUpdate;
	bool mUseYCoCg;
	int  mDebugMode;
	float mDebugScale;
} pushConstants;

layout(set = 1, binding = 0) uniform Matrices {
	mat4 mHistoryViewProjMatrix;
	mat4 mInverseViewProjMatrix;
} uboMat;
// -------------------------------------------------------

// ###### HELPER FUNCTIONS ###############################

// convert from RGB to YCoCg-R ; see https://en.wikipedia.org/wiki/YCoCg
vec3 rgb_to_ycocg(vec3 c) {
	float co  = c.r - c.b;
	float tmp = c.b + co * .5;
	float cg  = c.g - tmp;
	float y   = tmp + cg * .5;
	return vec3(y,co,cg);
}

// convert from YCoCg-R to RGB
vec3 ycocg_to_rgb(vec3 c) {
	float tmp = c.x - c.z * .5;
	float g   = c.z + tmp;
	float b   = tmp - c.y * .5;
	float r   = b + c.y;
	return vec3(r,g,b);
}

vec3 maybe_rgb_to_ycocg(vec3 c) { return pushConstants.mUseYCoCg ? rgb_to_ycocg(c) : c; }
vec3 maybe_ycocg_to_rgb(vec3 c) { return pushConstants.mUseYCoCg ? ycocg_to_rgb(c) : c; }

void getNeighbourhood(in ivec2 iuv, out vec3 cC, out vec3 c1, out vec3 c2, out vec3 c3, out vec3 c4, out vec3 c5, out vec3 c6, out vec3 c7, out vec3 c8) {
	vec2 offset = vec2(0.0, 0.0);
	if (pushConstants.mTextureLookupUnjitter) {
		offset = pushConstants.mJitterAndAlpha.xy;
	}
	vec2 invsize = vec2(1) / textureSize(uCurrentFrame, 0);

	cC = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv                 + 0.5) * invsize).rgb);
	c1 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1, -1) + 0.5) * invsize).rgb);
	c2 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0, -1) + 0.5) * invsize).rgb);
	c3 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1, -1) + 0.5) * invsize).rgb);
	c4 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  0) + 0.5) * invsize).rgb);
	c5 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  0) + 0.5) * invsize).rgb);
	c6 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2(-1,  1) + 0.5) * invsize).rgb);
	c7 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 0,  1) + 0.5) * invsize).rgb);
	c8 = maybe_rgb_to_ycocg(texture(sampler2D(uCurrentFrame, uSampler), offset + vec2(iuv + ivec2( 1,  1) + 0.5) * invsize).rgb);
}

void getColorAndAabb(in ivec2 iuv, out vec3 centerCol, out vec3 minCol, out vec3 maxCol)
{
	vec3 c1,c2,c3,c4,c5,c6,c7,c8;
	getNeighbourhood(iuv, centerCol,c1,c2,c3,c4,c5,c6,c7,c8);
	minCol = min(min(min(min(min(min(min(min(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
	maxCol = max(max(max(max(max(max(max(max(centerCol, c1), c2), c3), c4), c5), c6), c7), c8);
}

// Code from Temporal Reprojection Anti-Aliasing in INSIDE: https://youtu.be/2XXS5UyNjjU?t=939
// note: clips towards aabb center + p.w
vec4 clipAabb(
	vec3 aabbMin, // cn_min
	vec3 aabbMax, // cn_max
	vec4 p,       // c_in'
	vec4 q)       // c_hist
{
	vec3 pClip = 0.5 * (aabbMax + aabbMin);
	vec3 eClip = 0.5 * (aabbMax - aabbMin);

	vec4 vClip = q - vec4(pClip, p.w);
	vec3 vUnit = vClip.xyz / eClip;
	vec3 aUnit = abs(vUnit);
	float maUnit = max(aUnit.x, max(aUnit.y, aUnit.z));

	if (maUnit > 1.0) {
		return vec4(pClip, p.w) + vClip / maUnit;
	}
	else {
		return q; // point inside aabb
	}
}

#if TAA_OUTPUT_IS_SRGB
float srgbGammaCorr(float color)
{
	if (color <= 0.0031308)
		return 12.92 * color;

	float a = 0.055;
	return (1 + a) * pow(color, 1 / 2.4) - a;
}

vec3 rgb2srgb(vec3 rgb)
{
	vec3 srgb;
	srgb.r = srgbGammaCorr(rgb.r);
	srgb.g = srgbGammaCorr(rgb.g);
	srgb.b = srgbGammaCorr(rgb.b);
	return srgb;
}

#define TO_OUTPUT_FORMAT(x) rgb2srgb((x))
#else
#define TO_OUTPUT_FORMAT(x) (x)
#endif

// -------------------------------------------------------

// ################## COMPUTE SHADER MAIN ###################
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
	ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(iuv) + 0.5) / textureSize(uCurrentFrame, 0);

	if (pushConstants.mBypassHistoryUpdate) {
		imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(texelFetch(uHistoryFrame, iuv, 0).rgb), 1));
		imageStore(uDebug,  iuv, vec4(0));
		return;
	}

	bool rejected  = false;
	bool rectified = false;
	vec3 rectified_diff;
	
	vec3 currentColor;
	vec3 colMin;
	vec3 colMax;
	getColorAndAabb(iuv, currentColor, colMin, colMax);		// colors are in YCoGg (if enabled)
	float depth = texelFetch(uCurrentDepth, iuv, 0).r;
	
	vec4 clipSpace = vec4(uv * 2.0 - 1.0, depth, 1);
	vec4 worldSpace = uboMat.mInverseViewProjMatrix * clipSpace;
	vec4 historyClipSpace = uboMat.mHistoryViewProjMatrix * worldSpace;
	vec2 historyUv = (historyClipSpace.xy / historyClipSpace.w) * 0.5 + 0.5;
	ivec2 iHistoryUv = ivec2(historyUv * textureSize(uCurrentDepth, 0));
	float expectedHistoryDepth = historyClipSpace.z / historyClipSpace.w;
	
	vec3 historyColor = maybe_rgb_to_ycocg(texture(sampler2D(uHistoryFrame, uSampler), historyUv).rgb);

	vec2 jitter = pushConstants.mJitterAndAlpha.xy;
	float alpha = pushConstants.mJitterAndAlpha.a;

	// ---- history rejection ----
	// cull by depth
	if (pushConstants.mDepthCulling) {
		float historyDepth = texelFetch(uHistoryDepth, iHistoryUv, 0).r;
		float depthEpsilon = 0.1 * (1.0 - historyDepth);
		if (abs(historyDepth - expectedHistoryDepth) > depthEpsilon) {
			alpha = 1;
			rejected = true;
		}
	}

	// ---- history rectification ----
	vec3 origHistorColor = historyColor;

	// clip color
	switch (pushConstants.mColorClampingOrClipping) {
		case 1:
			historyColor = clamp(historyColor, colMin, colMax);
			break;
		case 2:
			historyColor = clipAabb(colMin, colMax, vec4(currentColor, 1.0), vec4(historyColor, 1.0)).rgb;
			// TODO: Implemented ^ this in a hurry => not properly tested and verified yet.
			break;
	}

	rectified_diff = historyColor - origHistorColor;
	rectified = any(greaterThan(abs(rectified_diff), vec3(0.001)));


	// ---- blending ----
	vec3 antiAliased = maybe_ycocg_to_rgb(currentColor) * alpha + maybe_ycocg_to_rgb(historyColor) * (1.0 - alpha);

	// if TAA_OUTPUT_IS_SRGB:
	// write rgb into uResult
	// - imageStore() cannot handle sRGB images
	// - we write sRGB values into an RGB image and copy the image into an sRGB image later as a workaround
	// => we have to manually convert linear RGB to sRGB

	imageStore(uResult, iuv, vec4(TO_OUTPUT_FORMAT(antiAliased), 1.0));

	// --- debug ---

	if (pushConstants.mDebugMode == 1) {
		// colour bounding box, individual
		vec3 tmp = colMax - colMin;
		imageStore(uDebug,  iuv, vec4(tmp, 0));
	} else if (pushConstants.mDebugMode == 2) {
		// colour bounding box, size
		vec3 tmp = colMax - colMin;
		imageStore(uDebug,  iuv, vec4(vec3(tmp.x * tmp.y * tmp.z) * pushConstants.mDebugScale, 0));
	} else if (pushConstants.mDebugMode == 3) {
		//imageStore(uDebug,  iuv, vec4(rejected ? 1 : 0, rectified ? 1 : 0, 0, 0));
		imageStore(uDebug,  iuv, vec4(rejected ? 1 : 0, length(rectified_diff) * pushConstants.mDebugScale, 0, 0));
	}

}
// -------------------------------------------------------

